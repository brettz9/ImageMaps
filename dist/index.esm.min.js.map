{"version":3,"file":"index.esm.min.js","sources":["../src/jquery.imageMaps.js"],"sourcesContent":["// The MIT License (MIT)\n\n// Copyright (c) 2016 NAVER Corp.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n/**\n* imageMaps 1.1.0\n* jquery plugin which can be partially linked to the image\n*\n* https://github.com/naver/ImageMaps\n* demo - http://naver.github.io/ImageMaps/\n*\n* Released on: July 6, 2016\n*/\n\n/**\n* @external jQuery\n*/\n/**\n * @typedef {number} Integer\n */\n/**\n * @typedef {number} Float\n */\n/**\n* @typedef {String} Url\n*/\n/**\n * @typedef {object} PlainObject\n */\n/**\n* @typedef {Array} GenericArray\n*/\n\n/**\n* @typedef\n* {\"rect\"|\"circle\"|\"ellipse\"|\"text\"|\"image\"|\"poly\"|\"polyline\"|\"polygon\"}\n* ShapeType\n*/\n\nconst SHAPE = {\n    RECT: 'rect',\n    CIRCLE: 'circle',\n    ELLIPSE: 'ellipse',\n    TEXT: 'text',\n    IMAGE: 'image',\n    POLY: 'poly',\n    POLYLINE: 'polyline',\n    POLYGON: 'polygon'\n};\n\n/**\n * @see https://api.jquery.com/css/\n * @typedef {PlainObject} ShapeStyles\n*/\n\n/**\n* @typedef {PlainObject} ImageMapOptions\n* @property {boolean} [isEditMode=false]\n* @property {ShapeType} [shape=\"rect\"]\n* @property {string} [shapeText=\"press on link\"]\n* @property {ShapeStyles} [shapeStyle] Defaults to\n*   `{fill: '#ffffff', 'fill-opacity': 0.2,\n*     stroke: '#ffffff', 'stroke-width': 3}`\n* @property {function} [onClick=function () {}]\n* @property {function} [onMouseDown=function () {}]\n* @property {function} [onMouseMove=function () {}]\n* @property {function} [onMouseUp=function () {}]\n* @property {function} [onSelect=function () {}]\n*/\n\n/**\n * @type {ImageMapOptions}\n */\nconst defaults = {\n    isEditMode: false,\n    // select map area shape type - rect, circle, text, image, poly\n    shape: SHAPE.RECT,\n    shapeText: 'press on link', // shape 옵션이 text일 때 적용된다.\n    shapeStyle: {\n        fill: '#ffffff',\n        'fill-opacity': 0.2,\n        stroke: '#ffffff',\n        'stroke-width': 3\n    },\n    /* eslint-disable no-empty-function */\n    onClick () {},\n    onMouseDown () {},\n    onMouseMove () {},\n    onMouseUp () {},\n    onSelect () {}\n    /* eslint-enable no-empty-function */\n};\n\nconst defaultShapeOptions = {\n    // top-left-x, top-left-y, bottom-right-x, botton-right-y\n    rect: [0, 0, 20, 20],\n    circle: [0, 0, 10], // center-x, center-y, radius\n    ellipse: [0, 0, 5, 5], // center-x, center-y, radius-x, radius-y\n    text: [0, 0, 12] // bottom-right-x, bottom-right-y, font-size\n};\n\nconst FONT_SIZE_RATIO = 0.5;\n\nconst NS_SVG = 'http://www.w3.org/2000/svg';\nconst NS_XLINK = 'http://www.w3.org/1999/xlink';\n\n/**\n *\n * @param {jQuery} $\n * @returns {jQuery}\n */\nfunction jqueryImageMaps ($) {\n    // The actual plugin constructor\n    class ImageMaps {\n        /**\n         *\n         * @param {jQuery} container\n         * @param {ImageMapOptions} options\n         */\n        constructor (container, options) {\n            this.container = $(container);\n            this.mapEl = null;\n            this.svgEl = null;\n            // merge the default options with user-provided options\n\n            this.options = $.extend(true, {}, defaults, options);\n            this.shapeType = this.options.shape;\n            this.isEditMode = this.options.isEditMode;\n            this.shapeStyle = this.options.shapeStyle;\n            this.shapeText = '';\n            this.shapeImageUrl = '';\n            this.shapeCoords = null;\n            this.vertexCoords = null;\n            this.grabType = null;\n\n            this.containerWidth = 0;\n            this.containerHeight = 0;\n\n            this.touchStartCoords = {\n                x: null, y: null\n            };\n            this.dragInfo = {\n                face: {x: null, y: null},\n                vertex: {x: null, y: null}\n            };\n\n            this.shapeLimitCoords = {\n                x: 30,\n                y: 30,\n                radius: 15\n            };\n\n            this.allShapeInfo = {};\n        }\n\n        /**\n         * ImageMaps: 이미지 엘리먼트 하단에 map, area 엘리먼트 생성 및 속성 부여.\n         * @param {Coords} coords\n         * @param {Url} linkUrl\n         * @returns {undefined}\n         */\n        createMaps (coords, linkUrl) {\n            const imageWidth = this.container.width();\n\n            if (isNaN(imageWidth) || !imageWidth) {\n                this.container.one(\n                    'load',\n                    $.proxy(createMaps, this, coords, linkUrl)\n                );\n            } else {\n                createMaps.call(this, coords, linkUrl);\n            }\n        }\n\n        /**\n         * @param {ShapeType} shapeType\n         * @returns {undefined}\n         */\n        setShapeType (shapeType) {\n            this.shapeType = shapeType;\n        }\n\n        /**\n         *\n         * @param {ShapeStyles} styleOptions\n         * @returns {undefined}\n         */\n        setShapeStyle (styleOptions) {\n            styleOptions = styleOptions || {};\n            this.shapeStyle = $.extend({}, true, this.shapeStyle, styleOptions);\n        }\n\n        /**\n         * @todo Implement\n         * @param {Url} linkUrl\n         * @param {Integer} index\n         * @returns {undefined}\n         */\n        setUrl (linkUrl, index) { // eslint-disable-line class-methods-use-this\n            // Todo\n        }\n\n        /**\n         *\n         * @param {string} text\n         * @param {ShapeStyles} styleOptions\n         * @returns {undefined}\n         */\n        setTextShape (text, styleOptions) {\n            this.setShapeStyle(styleOptions);\n            this.shapeText = text;\n        }\n\n        /**\n         *\n         * @param {string} imageUrl\n         * @param {ShapeStyles} styleOptions\n         * @returns {undefined}\n         */\n        setImageShape (imageUrl, styleOptions) {\n            this.setShapeStyle(styleOptions);\n            this.shapeImageUrl = imageUrl;\n        }\n\n        /**\n         *\n         * @param {Coords} coords\n         * @param {Url} linkUrl\n         * @param {ShapeType} shapeType\n         * @returns {undefined}\n         */\n        addShape (coords, linkUrl, shapeType) {\n            if (shapeType) {\n                this.setShapeType(shapeType);\n            }\n            this.createMaps(coords, linkUrl);\n        }\n\n        /**\n         * @param {Integer} index\n         * @returns {undefined}\n         */\n        removeShape (index) {\n            if (!this.shapeEl) {\n                return;\n            }\n\n            if (typeof index === 'undefined') {\n                index = this.shapeEl.data('index');\n            }\n\n            const areaEl = this.mapEl.find('area[data-index=\"' + index + '\"]');\n            const shapeEl = this.svgEl.find(\n                '._shape_face[data-index=\"' + index + '\"]'\n            );\n\n            this.detachEvents(shapeEl, [{\n                type: 'click touchend'\n            }]);\n\n            shapeEl.parent().remove();\n            areaEl.remove();\n\n            this.removeShapeInfo(index);\n        }\n\n        /**\n         *\n         * @returns {undefined}\n         */\n        removeAllShapes () {\n            if (!this.shapeEl) {\n                return;\n            }\n\n            const allShapeEls = this.svgEl.find('._shape_face');\n\n            allShapeEls.each((i, shapeEl) => {\n                this.removeShape($(shapeEl).data('index'));\n            });\n\n            this.allShapeInfo = {};\n        }\n\n        /**\n         *\n         * @returns {undefined}\n         */\n        removeImageMaps () {\n            this.removeAllShapes();\n            this.svgEl && this.svgEl.remove();\n        }\n\n        /**\n        * @typedef {PlainObject} ShapeInfoOptions\n        * @property {Integer} index\n        * @property {ShapeCoords} coords\n        * @property {ShapeType} type\n        * @property {Url} url\n        * @property {ShapeStyles} style\n        */\n\n        /**\n        * @typedef {PlainObject} ShapeSecondaryOptions\n        * @property {string} text\n        * @property {HTMLImageElement|string} href\n        */\n\n        /**\n         *\n         * @param {Integer} index\n         * @param {ShapeInfoOptions} shapeOptions\n         * @param {ShapeSecondaryOptions} shapeSecondaryOptions\n         * @returns {undefined}\n         */\n        updateShapeInfo (index, shapeOptions, shapeSecondaryOptions) {\n            const shapeInfo = this.allShapeInfo;\n\n            shapeOptions.index = index;\n            if (!shapeInfo['shape' + index]) {\n                shapeInfo['shape' + index] = $.extend(\n                    true, shapeOptions, shapeSecondaryOptions\n                );\n            } else {\n                shapeInfo['shape' + index] = $.extend(\n                    true,\n                    {},\n                    shapeInfo['shape' + index],\n                    shapeOptions,\n                    shapeSecondaryOptions\n                );\n            }\n        }\n\n        /**\n         * @param {Integer} index\n         * @returns {undefined}\n         */\n        removeShapeInfo (index) {\n            delete this.allShapeInfo['shape' + index];\n        }\n\n        /**\n         *\n         * @param {Integer} index\n         * @returns {ShapeInfoOptions|ShapeSecondaryOptions}\n         */\n        getShapeInfo (index) {\n            return this.allShapeInfo['shape' + index];\n        }\n\n        /**\n        * @typedef {PlainObject} AllShapeInfo\n        * @property {ShapeType} type\n        * @property {Coords} coords\n        * @property {Integer} index\n        * @property {ShapeInfoOptions|ShapeSecondaryOptions} shape<num>\n        */\n        /**\n         *\n         * @returns {AllShapeInfo}\n         */\n        getAllShapesInfo () {\n            return $.extend(true, {}, this.allShapeInfo);\n        }\n\n        /**\n         *\n         * @param {Float[]} percentages\n         * @returns {undefined}\n         */\n        zoom (percentages) {\n            zoom.call(this, percentages);\n        }\n\n        /**\n         *\n         * @returns {undefined}\n         */\n        enableClick () {\n            this.attachEvents(this.svgEl.find('._shape_face'), [{\n                type: 'touchstart', handler: onTouchStart\n            }, {\n                type: 'click touchend', handler: onClickShapeFace\n            }]);\n        }\n\n        /**\n         *\n         * @returns {undefined}\n         */\n        disableClick () {\n            this.detachEvents(this.svgEl.find('._shape_face'), [{\n                type: 'touchstart', handler: onTouchStart\n            }, {\n                type: 'click touchend', handler: onClickShapeFace\n            }]);\n        }\n\n        /**\n         *\n         * @param {ShapeCoords} coords\n         * @returns {undefined}\n         */\n        setShapeCoords (coords) {\n            this.shapeCoords = coords;\n        }\n\n        /**\n         *\n         * @param {VertexCoords} coords\n         * @returns {undefined}\n         */\n        setVertexCoords (coords) {\n            this.vertexCoords = coords;\n        }\n\n        /**\n         *\n         * @param {ShapeElement} element\n         * @returns {undefined}\n         */\n        setShapeElement (element) {\n            this.shapeEl = element;\n        }\n\n        /**\n        * @typedef {Element} VertexElement\n        */\n        /**\n         *\n         * @param {VertexElement} element\n         * @returns {undefined}\n         */\n        setVertexElement (element) {\n            this.vertexEl = element;\n        }\n\n        /**\n         *\n         * @param {VertexElements} elements\n         * @returns {undefined}\n         */\n        setVertexElements (elements) {\n            this.vertexEls = elements;\n        }\n\n        /**\n        * @typedef {PlainObject} TypeHandler\n        * @property {string} type\n        * @property {function} handler\n        */\n        /**\n         * ImageMaps: 이미지맵 이벤트 할당.\n         * @param {Node|jQuery} element\n         * @param {TypeHandler[]} eventOptions\n         * @returns {undefined}\n         */\n        attachEvents (element, eventOptions) {\n            element = $(element);\n\n            eventOptions.forEach(({type, handler}) => {\n                element.on(\n                    type + '.area',\n                    $.proxy(handler, this)\n                );\n            });\n        }\n\n        /**\n         * ImageMaps: 이미지맵 이벤트 해제.\n         * @param {jQuery} element\n         * @param {TypeHandler[]} eventOptions\n         * @returns {undefined}\n         */\n        detachEvents (element, eventOptions) {\n            element = $(element);\n\n            eventOptions.forEach(({type, handler}) => {\n                const eventType = type || '';\n                const eventHandler = handler\n                    ? $.proxy(handler, this)\n                    : '';\n\n                if (eventHandler) {\n                    element.off(eventType + '.area', eventHandler);\n                } else {\n                    element.off(eventType + '.area');\n                }\n            });\n        }\n    }\n    ImageMaps.getCoordsByRatio = getCoordsByRatio;\n\n    /**\n     * @this ImageMaps\n     * @param {Coords} coords\n     * @param {Url} linkUrl\n     * @returns {undefined}\n     */\n    function createMaps (coords, linkUrl) {\n        // 최초 맵영역을 만드는 순간에 map 엘리먼트를 만들고 하위에 area 엘리먼트 생성.\n        const uid = guid();\n        if (!this.container.attr('usemap')) {\n            this.mapEl = $(\n                '<map name=' + uid + '></map>'\n            ).insertAfter(this.container);\n            this.container.attr('usemap', '#' + uid);\n        } else {\n            const usemapName = this.container.attr('usemap').replace('#', '');\n            this.mapEl = $('body').find('map[name=' + usemapName + ']');\n        }\n\n        this.containerWidth = this.container.width();\n        this.containerHeight = this.container.height();\n\n        const imageWidth = this.containerWidth;\n        const imageHeight = this.containerHeight;\n        const centerX = imageWidth / 2;\n        const centerY = imageHeight / 2;\n\n        // 파라미터로 좌표값을 받으면 좌표에 해당하는 영역을 함께 그려준다.\n        const {shapeType} = this;\n\n        let shapeCoords = [];\n        let isDefaultTextCoords = false;\n\n        coords = convertStringToNumber(coords);\n        if (!(Array.isArray(coords))) {\n            // default 편집영역의 사이즈는 이미지의 0.1배로 계산. (내 맘대로..)\n            let defaultShapeX = imageWidth * 0.1,\n                defaultShapeY = imageHeight * 0.1;\n            const defaultRadius = (defaultShapeX >= defaultShapeY)\n                ? defaultShapeY\n                : defaultShapeX;\n            // invalid 좌표값이거나 배열이 아닌 타입일 경우는 디폴트 좌표로 그린다.\n            if (shapeType === SHAPE.RECT) {\n                shapeCoords = $.extend([], defaultShapeOptions.rect, [\n                    centerX - defaultShapeX,\n                    centerY - defaultShapeY,\n                    centerX + defaultShapeX,\n                    centerY + defaultShapeY\n                ]);\n            } else if (shapeType === SHAPE.CIRCLE) {\n                shapeCoords = $.extend([], defaultShapeOptions.circle, [\n                    centerX,\n                    centerY,\n                    defaultRadius\n                ]);\n            } else if (shapeType === SHAPE.ELLIPSE) {\n                shapeCoords = $.extend([], defaultShapeOptions.ellipse, [\n                    centerX,\n                    centerY,\n                    defaultRadius,\n                    defaultRadius\n                ]);\n            } else if (shapeType === SHAPE.IMAGE) {\n                const imageSize = getNaturalImageSize(this.shapeImageUrl);\n                defaultShapeX = imageSize.width / 2;\n                defaultShapeY = imageSize.height / 2;\n                shapeCoords = [\n                    centerX - defaultShapeX,\n                    centerY - defaultShapeY,\n                    centerX + defaultShapeX,\n                    centerY + defaultShapeY\n                ];\n            } else if (shapeType === SHAPE.POLY) {\n                // Todo\n            }\n        } else {\n            // 타입별로 정상적으로 좌표값을 받았다면 해당 좌표로 그린다.\n            // eslint-disable-next-line no-lonely-if\n            if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n                shapeCoords = $.extend([], defaultShapeOptions.rect, coords);\n            } else if (shapeType === SHAPE.CIRCLE) {\n                shapeCoords = $.extend([], defaultShapeOptions.circle, coords);\n            } else if (shapeType === SHAPE.ELLIPSE) {\n                shapeCoords = $.extend([], defaultShapeOptions.ellipse, coords);\n            } else if (shapeType === SHAPE.TEXT) {\n                if (!coords[0]) {\n                    coords[0] = centerX;\n                    isDefaultTextCoords = true;\n                }\n                if (!coords[1]) {\n                    coords[1] = centerY;\n                    isDefaultTextCoords = true;\n                }\n                if (!coords[2]) {\n                    coords[2] = 20;\n                }\n                shapeCoords = $.extend([], defaultShapeOptions.text, coords);\n            } else if (shapeType === SHAPE.POLY) {\n                // Todo\n            }\n        }\n\n        const index = this.mapEl.find('._shape_face').length;\n        let areaType = shapeType;\n        let shapeSecondaryOptions = {};\n\n        if (shapeType === SHAPE.TEXT || shapeType === SHAPE.IMAGE) {\n            areaType = SHAPE.RECT;\n\n            if (shapeType === SHAPE.TEXT) {\n                shapeSecondaryOptions = {text: this.shapeText};\n            } else {\n                shapeSecondaryOptions = {href: this.shapeImageUrl};\n            }\n        }\n\n        createOverlay.call(this, shapeCoords, uid, linkUrl, index);\n        this.setShapeCoords(shapeCoords);\n        this.updateShapeInfo(index, {\n            coords: shapeCoords,\n            type: shapeType,\n            url: linkUrl,\n            style: this.shapeStyle\n        }, shapeSecondaryOptions);\n\n        if (isDefaultTextCoords && this.isEditMode &&\n            shapeType === SHAPE.TEXT\n        ) {\n            adjustTextShape.call(this);\n        }\n\n        if (shapeType === SHAPE.ELLIPSE) {\n            areaType = SHAPE.CIRCLE;\n            shapeCoords = [\n                shapeCoords[0],\n                shapeCoords[1],\n                defaultShapeOptions.ellipse[2],\n                defaultShapeOptions.ellipse[2]\n            ];\n        }\n\n        createArea.call(this, areaType, shapeCoords, linkUrl, index);\n    }\n\n    /**\n     * @this ImageMaps\n     * @param {ShapeCoords} shapeCoords\n     * @param {string} uid\n     * @param {Url} linkUrl\n     * @param {Integer} index\n     * @returns {undefined}\n     */\n    function createOverlay (shapeCoords, uid, linkUrl, index) {\n        const containerWidth = this.container.width(),\n            containerHeight = this.container.height();\n\n        if (typeof document.createElementNS !== 'undefined') {\n            let svgNativeEl = this.mapEl.find('svg').get(0);\n            let svgEl = $(svgNativeEl);\n            const {shapeType} = this;\n\n            if (!svgNativeEl) {\n                svgNativeEl = document.createElementNS(NS_SVG, 'svg');\n                svgEl = $(svgNativeEl);\n                this.svgEl = svgEl;\n\n                if (this.isEditMode) {\n                    this.attachEvents(svgEl, [{\n                        type: 'mousedown', handler: onMouseDown\n                    }]);\n                } else {\n                    this.attachEvents(this.mapEl, [{\n                        type: 'touchstart', handler: onTouchStart\n                    }, {\n                        type: 'click touchend', handler: onClickShapeFace\n                    }]);\n                }\n                this.attachEvents(window, [{\n                    type: 'resize', handler: onResize\n                }]);\n            }\n\n            // svgEl.get(0).setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n            // svg의 width, height는 DOM API로 처리해야 사이즈가 제대로 나옴.\n            svgNativeEl.setAttribute('width', containerWidth);\n            svgNativeEl.setAttribute('height', containerHeight);\n\n            // container의 부모에 대한 상대좌표에 따라 svg의 좌표값이 결정된다.\n            const containerPos = this.container.position();\n            svgEl.attr({\n                xmlns: NS_SVG,\n                'xmlns:xlink': NS_XLINK,\n                version: '1.1',\n                'data-Id': uid\n            }).css({\n                position: 'absolute',\n                zIndex: 1000,\n                overflow: 'hidden',\n                top: containerPos.top,\n                left: containerPos.left\n            });\n\n            const shapeGroupEl = createShape.call(\n                this,\n                shapeType,\n                shapeCoords,\n                linkUrl,\n                index\n            );\n            svgEl.append(shapeGroupEl);\n            this.mapEl.append(svgEl);\n        }\n    }\n\n    /**\n     * @this ImageMaps\n     * @param {string} areaType\n     * @param {ShapeCoords} shapeCoords\n     * @param {Url} linkUrl\n     * @param {string|Integer} index\n     * @returns {undefined}\n     */\n    function createArea (areaType, shapeCoords, linkUrl, index) {\n        $(\n            '<area shape=' + areaType +\n                ' coords=' + shapeCoords.join(',') +\n                ' href=' + (linkUrl || '#') +\n                ' data-index=' + index + ' ' +\n                (linkUrl ? 'target=\"_blank\"' : '') +\n                '>'\n        ).appendTo(this.mapEl);\n    }\n\n    /**\n     * @this ImageMaps\n     * @param {ShapeType} shapeType\n     * @param {ShapeCoords} shapeCoords\n     * @param {Url} linkUrl\n     * @param {string|Integer} index\n     * @returns {undefined}\n     */\n    function createShape (shapeType, shapeCoords, linkUrl, index) {\n        if (shapeType === SHAPE.POLY) {\n            shapeType = SHAPE.POLYLINE;\n        }\n\n        const shapeEl = $(document.createElementNS(NS_SVG, shapeType));\n        const gEl = $(document.createElementNS(NS_SVG, 'g'));\n\n        drawShape.call(this, shapeCoords, shapeEl);\n\n        let cursor = 'default';\n        if (this.isEditMode) {\n            cursor = 'move';\n        } else if (linkUrl !== '') {\n            cursor = 'pointer';\n        }\n        this.setShapeStyle({cursor});\n        shapeEl.css(this.shapeStyle);\n\n        if (shapeType === SHAPE.TEXT) {\n            shapeEl.css({\n                'fill-opacity': '',\n                'stroke-opacity': ''\n            });\n        }\n\n        shapeEl.attr('data-index', index);\n        gEl.append(shapeEl);\n        this.setShapeElement(shapeEl);\n\n        if (this.isEditMode && shapeType !== 'text') {\n            const vertexEls = createVertex(shapeType, shapeCoords, index);\n            gEl.append(...vertexEls);\n            this.setVertexElements(vertexEls);\n        }\n\n        return gEl;\n    }\n\n    /**\n    * @typedef {PlainObject} ShapeOptions\n    * @property {string} text\n    * @property {string} href\n    * @property {ShapeType} type\n    */\n\n    /**\n     * @this ImageMaps\n     * @param {ShapeCoords} shapeCoords\n     * @param {ShapeElement} shapeEl\n     * @param {ShapeOptions} shapeOptions\n     * @returns {undefined}\n     */\n    function drawShape (shapeCoords, shapeEl, shapeOptions) {\n        shapeEl = shapeEl || this.shapeEl;\n        const shapeType = shapeOptions ? shapeOptions.type : this.shapeType;\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            shapeEl.attr({\n                x: shapeCoords[0],\n                y: shapeCoords[1],\n                class: '_shape_face'\n            });\n            if (shapeCoords[2]) {\n                shapeEl.attr('width', shapeCoords[2] - shapeCoords[0]);\n            }\n            if (shapeCoords[3]) {\n                shapeEl.attr('height', shapeCoords[3] - shapeCoords[1]);\n            }\n            if (shapeType === SHAPE.IMAGE) {\n                // xlink 속성 설정 시에는 DOM api의 setAttributeNS를 사용해야 함.\n                // svg 전용 속성은 무조건 DOM api를 사용해야 함.\n                shapeEl.get(0).setAttributeNS(\n                    NS_XLINK,\n                    'href',\n                    (shapeOptions ? shapeOptions.href : this.shapeImageUrl)\n                );\n                // image 엘리먼트의 width, height를 고정 비율로 변경되는 걸 해제해주기 위한 속성 셋팅.\n                shapeEl.get(0).setAttribute('preserveAspectRatio', 'none');\n            }\n        } else if (shapeType === SHAPE.CIRCLE) {\n            shapeEl.attr({\n                cx: shapeCoords[0],\n                cy: shapeCoords[1],\n                class: '_shape_face'\n            });\n            if (shapeCoords[2]) {\n                shapeEl.attr('r', shapeCoords[2]);\n            }\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            shapeEl.attr({\n                cx: shapeCoords[0],\n                cy: shapeCoords[1],\n                class: '_shape_face'\n            });\n            if (shapeCoords[2]) {\n                shapeEl.attr('rx', shapeCoords[2]);\n            }\n            if (shapeCoords[3]) {\n                shapeEl.attr('ry', shapeCoords[3]);\n            }\n        } else if (shapeType === SHAPE.TEXT) {\n            shapeEl.attr({\n                x: shapeCoords[0],\n                y: shapeCoords[1],\n                'font-size': shapeCoords[2],\n                class: '_shape_face'\n            });\n            shapeEl.text((shapeOptions && shapeOptions.text) || this.shapeText);\n        } else if (shapeType === SHAPE.POLY) {\n            // Todo\n        }\n    }\n\n    /**\n     * @this ImageMaps\n     * @returns {undefined}\n     */\n    function adjustTextShape () {\n        const {shapeEl} = this;\n        const shapeSize = shapeEl.get(0).getBBox();\n        const centerX = shapeSize.width / 2;\n        const centerY = parseFloat(\n            shapeEl.attr('font-size')\n        ) * FONT_SIZE_RATIO / 2;\n        const bottomRightX = parseInt(shapeEl.attr('x'));\n        const bottomRightY = parseInt(shapeEl.attr('y'));\n        const resultX = bottomRightX - centerX;\n        const resultY = bottomRightY + centerY;\n\n        this.updateShapeInfo(shapeEl.data('index'), {\n            coords: [resultX, resultY, shapeEl.attr('font-size')]\n        });\n\n        shapeEl.attr({\n            x: resultX,\n            y: resultY\n        });\n    }\n\n    /**\n    * @typedef {SVGRect[]} VertexElements One `SVGRect` element for each\n    *     vertex coordinate\n    */\n\n    /**\n     * @static\n     * @param {ShapeType} shapeType\n     * @param {ShapeCoords} shapeCoords\n     * @param {Integer} index\n     * @returns {VertexElements}\n     */\n    function createVertex (shapeType, shapeCoords, index) {\n        const vertexCoords = calculateVertexCoords(shapeType, shapeCoords);\n\n        const vertexTemp = vertexCoords.map(() => {\n            const vertexEl = $(document.createElementNS(NS_SVG, 'rect'));\n            vertexEl.attr('data-index', index).css({\n                fill: '#ffffff',\n                stroke: '#000000',\n                'stroke-width': 2\n            });\n            return vertexEl;\n        });\n\n        drawVertex(vertexCoords, vertexTemp, shapeType);\n\n        return vertexTemp;\n    }\n\n    /**\n    * @typedef {PlainObject} VertexCoords\n    * @property {Float} x\n    * @property {Float} y\n    * @property {CursorType} type\n    */\n\n    /**\n     * @static\n     * @param {VertexCoords} vertexCoords\n     * @param {VertexElements} vertexEls\n     * @param {ShapeType} shapeType\n     * @returns {undefined}\n     */\n    function drawVertex (vertexCoords, vertexEls, shapeType) {\n        vertexCoords.forEach((eachCoords, i) => {\n            $(vertexEls[i]).attr({\n                x: eachCoords.x - 3,\n                y: eachCoords.y - 3,\n                width: 7,\n                height: 7,\n                'data-direction': eachCoords.type,\n                class: '_shape_vertex'\n            }).css('cursor', getCursor(eachCoords.type));\n        });\n    }\n\n    /**\n    * @typedef {Coords} ShapeCoords\n    */\n\n    /**\n     * @static\n     * @param {ShapeType} shapeType\n     * @param {ShapeCoords} shapeCoords\n     * @returns {VertexCoords}\n     */\n    function calculateVertexCoords (shapeType, shapeCoords) {\n        let vertexArr = [];\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            // 좌상, 좌하, 우상, 우하, 상, 하, 좌, 우 순\n            // 개별 vertex의 좌표값이므로 좌표의 순서는 크게 상관 없지만 참고로...\n            vertexArr = [{\n                x: shapeCoords[0], y: shapeCoords[1], type: 'nw'\n            }, {\n                x: shapeCoords[0], y: shapeCoords[3], type: 'sw'\n            }, {\n                x: shapeCoords[2], y: shapeCoords[1], type: 'ne'\n            }, {\n                x: shapeCoords[2], y: shapeCoords[3], type: 'se'\n            }, {\n                x: (shapeCoords[2] - shapeCoords[0]) / 2 + shapeCoords[0],\n                y: shapeCoords[1], type: 'n'\n            }, {\n                x: (shapeCoords[2] - shapeCoords[0]) / 2 + shapeCoords[0],\n                y: shapeCoords[3],\n                type: 's'\n            }, {\n                x: shapeCoords[0],\n                y: (shapeCoords[3] - shapeCoords[1]) / 2 + shapeCoords[1],\n                type: 'w'\n            }, {\n                x: shapeCoords[2],\n                y: (shapeCoords[3] - shapeCoords[1]) / 2 + shapeCoords[1],\n                type: 'e'\n            }];\n        } else if (shapeType === SHAPE.CIRCLE) {\n            // 상, 하, 좌, 우\n            vertexArr = [{\n                x: shapeCoords[0], y: shapeCoords[1] - shapeCoords[2], type: 'n'\n            }, {\n                x: shapeCoords[0], y: shapeCoords[1] + shapeCoords[2], type: 's'\n            }, {\n                x: shapeCoords[0] - shapeCoords[2], y: shapeCoords[1], type: 'w'\n            }, {\n                x: shapeCoords[0] + shapeCoords[2], y: shapeCoords[1], type: 'e'\n            }];\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            // 상, 하, 좌, 우\n            vertexArr = [{\n                x: shapeCoords[0], y: shapeCoords[1] - shapeCoords[3], type: 'n'\n            }, {\n                x: shapeCoords[0], y: shapeCoords[1] + shapeCoords[3], type: 's'\n            }, {\n                x: shapeCoords[0] - shapeCoords[2], y: shapeCoords[1], type: 'w'\n            }, {\n                x: shapeCoords[0] + shapeCoords[2], y: shapeCoords[1], type: 'e'\n            }];\n        } else if (shapeType === SHAPE.POLY) {\n            // Todo\n        }\n\n        return vertexArr;\n    }\n\n    /**\n     * @this ImageMaps\n     * @param {ShapeCoords} shapeCoords\n     * @param {Element} areaEl\n     * @param {ShapeType} shapeType\n     * @returns {undefined}\n     */\n    function drawArea (shapeCoords, areaEl, shapeType) {\n        const shapeEl = this.svgEl.find(\n            '._shape_face[data-index=\"' + areaEl.data('index') + '\"]'\n        );\n        shapeType = shapeType || this.shapeType;\n\n        if (shapeType === SHAPE.TEXT) {\n            shapeCoords = convertTextToRectCoords(shapeEl);\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            shapeCoords = [\n                shapeCoords[0],\n                shapeCoords[1],\n                defaultShapeOptions.ellipse[2]\n            ];\n        }\n        areaEl.attr('coords', shapeCoords.join(','));\n    }\n\n    /**\n    * @typedef {\"col\"|\"row\"|Direction|\"ew\"|\"ns\"|\"nesw\"|\"nwse\"} CursorType\n    */\n    /**\n     * @static\n     * @param {CursorType} type\n     *     CSS cursor resize type\n     * @returns {string}\n     */\n    function getCursor (type) {\n        return type + '-resize';\n    }\n\n    /**\n     * @this ImageMaps\n     * @param {Event} e\n     * @returns {undefined}\n     */\n    function onTouchStart (e) {\n        const touchCoords = e.originalEvent.touches[0];\n        this.touchStartCoords.x = touchCoords.pageX;\n        this.touchStartCoords.y = touchCoords.pageY;\n    }\n\n    /**\n     * @this ImageMaps\n     * @param {Event} e\n     * @returns {undefined}\n     */\n    function onClickShapeFace (e) {\n        // IE8이 이외의 브라우저는 아래 계산 로직을 타지 않아도 된다.\n        // IE8은 area 엘리먼트 클릭 시 href 속성의 url로 이동.\n        let targetAreaEl;\n        if (e.currentTarget.tagName.toLowerCase() !== 'area') {\n            e.preventDefault();\n            if ((this.dragInfo.face.x && this.dragInfo.face.x !== e.pageX) ||\n                (this.dragInfo.face.y && this.dragInfo.face.y !== e.pageY) ||\n                e.target.tagName.toLowerCase() === 'svg' ||\n                (e.type === 'touchend' &&\n                    e.originalEvent.changedTouches[0].pageX !==\n                      this.touchStartCoords.x &&\n                    e.originalEvent.changedTouches[0].pageY !==\n                      this.touchStartCoords.y)\n            ) {\n                return;\n            }\n\n            // 클릭하거나 마우스엔터, 마우스다운 된 shape를 현재 타겟으로 저장.\n            // 타겟이 되는 shape의 좌표 정보를 가지고 모든 로직이 수행되도록 한다.\n            const targetEl = $(e.target);\n            const index = targetEl.attr('data-index');\n            targetAreaEl = this.mapEl.find('area[data-index=\"' + index + '\"]');\n            const url = targetAreaEl.attr('href');\n\n            (url !== '#') && window.open(targetAreaEl.attr('href'));\n        }\n\n        this.options.onClick.call(this, e, targetAreaEl.attr('href'));\n    }\n\n    // drag & drop\n\n    /**\n     * @this ImageMaps\n     * @param {Event} e\n     * @returns {undefined}\n     */\n    function onMouseDown (e) {\n        e.preventDefault();\n\n        if (e.target.tagName.toLowerCase() === 'svg') {\n            return;\n        }\n\n        const targetEl = $(e.target);\n        const index = targetEl.attr('data-index');\n        const shapeInfo = this.getShapeInfo(index);\n        const groupEl = targetEl.parent();\n        const shapeEl = groupEl.find(':first-child');\n        let coords = [];\n        let shapeType = shapeEl.get(0).tagName.toLowerCase();\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            const targetX = parseInt(shapeEl.attr('x'));\n            const targetY = parseInt(shapeEl.attr('y'));\n            coords = [\n                targetX,\n                targetY,\n                targetX + parseInt(shapeEl.attr('width')),\n                targetY + parseInt(shapeEl.attr('height'))\n            ];\n            if (shapeType === SHAPE.IMAGE) {\n                this.setImageShape(shapeEl.attr('href'));\n            }\n        } else if (shapeType === SHAPE.CIRCLE) {\n            const targetX = parseInt(shapeEl.attr('cx'));\n            const targetY = parseInt(shapeEl.attr('cy'));\n            coords = [targetX, targetY, parseInt(shapeEl.attr('r'))];\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            const targetX = parseInt(shapeEl.attr('cx'));\n            const targetY = parseInt(shapeEl.attr('cy'));\n            coords = [\n                targetX, targetY,\n                parseInt(shapeEl.attr('rx')),\n                parseInt(shapeEl.attr('ry'))\n            ];\n        } else if (shapeType === SHAPE.TEXT) {\n            const targetX = parseFloat(shapeEl.attr('x'));\n            const targetY = parseFloat(shapeEl.attr('y'));\n            const fontSize = parseFloat(shapeEl.attr('font-size'));\n            coords = [targetX, targetY, fontSize];\n            this.shapeText = shapeEl.text();\n        } else if (shapeType === SHAPE.POLYGON) {\n            shapeType = SHAPE.POLY;\n        }\n\n        this.setShapeType(shapeType);\n        this.setShapeElement(shapeEl);\n        this.setShapeCoords(coords);\n\n        if (shapeType !== SHAPE.TEXT) {\n            shapeEl.attr('data-fill', shapeEl.css('fill'));\n            shapeEl.css('fill', '#ffffff');\n\n            this.setVertexCoords(calculateVertexCoords(shapeType, coords));\n\n            const vertexTemp = [];\n            const vertexEls = this.mapEl.find(\n                '._shape_vertex[data-index=\"' + index + '\"]'\n            );\n            vertexEls.each(function () {\n                vertexTemp.push($(this));\n            });\n            this.setVertexElements(vertexTemp);\n        }\n\n        if (targetEl.is('._shape_face')) {\n            this.grabType = 'face';\n            declareShape.call(this, targetEl, e.pageX, e.pageY);\n        } else if (targetEl.is('._shape_vertex')) {\n            this.grabType = 'vertex';\n            declareVertex.call(this, targetEl, index);\n        }\n\n        this.attachEvents(this.mapEl.parent(), [{\n            type: 'mouseup', handler: onMouseUp\n        }, {\n            type: 'mousemove', handler: onMouseMove\n        }]);\n\n        this.options.onSelect.call(this, e, shapeInfo);\n        this.options.onMouseDown.call(this, e, shapeType, coords);\n    }\n\n    /**\n     * @this ImageMaps\n     * @param {Event} e\n     * @returns {undefined}\n     */\n    function onMouseUp (e) {\n        const targetEl = $(e.target);\n        const {shapeEl} = this;\n\n        shapeEl.css('fill', shapeEl.attr('data-fill'));\n        targetEl.attr('data-movable', false);\n\n        const updatedCoords = determineShape.call(this);\n        this.setShapeCoords(updatedCoords);\n        this.updateShapeInfo(shapeEl.data('index'), {coords: updatedCoords});\n\n        this.detachEvents(this.mapEl.parent(), [{\n            type: 'mouseup', handler: onMouseUp\n        }, {\n            type: 'mousemove', handler: onMouseMove\n        }]);\n\n        this.options.onMouseUp.call(this, e, this.shapeType, updatedCoords);\n    }\n\n    /**\n     * @this ImageMaps\n     * @param {Event} e\n     * @returns {undefined}\n     */\n    function onMouseMove (e) {\n        const targetEl = $(e.target);\n        const [x, y] = this.shapeCoords;\n        const {grabType, shapeType} = this;\n        let coords = {};\n\n        // 좌표 계산 시 e.offsetX, offsetY값은 이벤트 발생 대상(e.currentTarget)\n        //   기준 좌표 값이므로\n        // 이벤트 발생 도중(특히 mousemove) 겹치는 이벤트 타겟이 생기면 해당 타겟 기준\n        //    좌표로 변경되어 좌표가 튀는 현상 발생.\n        // 그러므로 브라우저에서 drag & drop 구현 시 웬만하면 브라우저의 절대 좌표값인\n        //    e.pageX, pageY를 사용하도록 한다.\n        if (grabType === 'face' || grabType === 'vertex') {\n            if (grabType === 'face') {\n                const movedX = x + e.pageX;\n                const movedY = y + e.pageY;\n\n                coords = getMovedShapeCoords.call(\n                    this,\n                    movedX - this.dragInfo.face.x,\n                    movedY - this.dragInfo.face.y\n                );\n            } else if (grabType === 'vertex') {\n                coords = getMovedVertexCoords.call(\n                    this,\n                    e.pageX - this.svgEl.offset().left,\n                    e.pageY - this.svgEl.offset().top\n                );\n            }\n            if (!coords) {\n                return;\n            }\n\n            if (shapeType !== SHAPE.TEXT) {\n                this.setVertexCoords(coords.vertexCoords);\n                drawVertex(coords.vertexCoords, this.vertexEls, this.shapeType);\n            }\n            const index = parseInt(coords.grabEl.attr('data-index'));\n            drawShape.call(\n                this,\n                coords.movedCoords,\n                this.svgEl.find('._shape_face[data-index=\"' + index + '\"]')\n            );\n            drawArea.call(\n                this,\n                coords.movedCoords,\n                this.mapEl.find('area[data-index=\"' + index + '\"]')\n            );\n\n            // svg 내 엘리먼트들은 z-index 영향을 받지 않고 document 순서에 영향을 받는다.\n            // 그래서 drag 시 다른 요소들보다 최상위에 두려면 엘리먼트 순서를 부모의 가장 하위에 두어야 한다.\n            // mousedown에서 이 로직을 넣을 경우,\n            // 외부에서 click 이벤트를 할당했을 때 mousedown 핸들러에서 dom 우선순위 조정하는 과정에서\n            //    click 이벤트가 해제되는 이슈로 mousemove 안에 둠.\n            if (\n                (\n                    targetEl.is('._shape_face') ||\n                    targetEl.is('._shape_vertex')\n                ) &&\n                (Math.abs(this.dragInfo.face.x - e.pageX) <= 1 ||\n                    Math.abs(this.dragInfo.face.y - e.pageY) <= 1)\n            ) {\n                this.svgEl.append(targetEl.parent());\n            }\n\n            this.options.onMouseMove.call(\n                this,\n                e,\n                shapeType,\n                coords.movedCoords\n            );\n        }\n    }\n\n    /**\n     * @this ImageMaps\n     * @param {Event} e\n     * @returns {undefined}\n     */\n    function onResize (e) {\n        const containerWidth = this.container.width();\n        const containerHeight = this.container.height();\n\n        if (this.containerWidth !== containerWidth ||\n            this.containerHeight !== containerHeight\n        ) {\n            redraw.call(this, containerWidth, containerHeight);\n        }\n    }\n\n    /**\n     * @this ImageMaps\n     * @param {Float[]} percentages\n     * @returns {undefined}\n     */\n    function zoom (percentages) {\n        const widthPercentage = percentages[0];\n        const heightPercentage = (percentages.length < 2)\n            ? widthPercentage\n            : percentages[1];\n        const containerWidth = widthPercentage * 0.01 * this.container.width();\n        const containerHeight = heightPercentage * 0.01 *\n            this.container.height();\n\n        this.container.css({\n            width: containerWidth + 'px',\n            height: containerHeight + 'px'\n        });\n\n        setTimeout(() => {\n            if (this.svgEl && this.svgEl.length > 0) {\n                redraw.call(this, containerWidth, containerHeight);\n            }\n        });\n    }\n\n    /**\n     * @this ImageMaps\n     * @param {Float} containerWidth\n     * @param {Float} containerHeight\n     * @returns {undefined}\n     */\n    function redraw (containerWidth, containerHeight) {\n        const {allShapeInfo} = this;\n        const widthRatio = containerWidth / this.containerWidth;\n        const heightRatio = containerHeight / this.containerHeight;\n        const containerPos = this.container.position();\n\n        this.svgEl.get(0).setAttribute('width', containerWidth);\n        this.svgEl.get(0).setAttribute('height', containerHeight);\n        this.svgEl.css({\n            top: containerPos.top,\n            left: containerPos.left\n        });\n\n        $.each(allShapeInfo, (index, item) => {\n            item.coords = getCoordsByRatio(\n                item.coords, item.type, widthRatio, heightRatio\n            );\n\n            drawVertex(\n                calculateVertexCoords(item.type, item.coords),\n                this.svgEl.find(\n                    '._shape_vertex[data-index=\"' + item.index + '\"]'\n                ),\n                item.type\n            );\n            drawShape.call(\n                this,\n                item.coords,\n                this.svgEl.find(\n                    '._shape_face[data-index=\"' + item.index + '\"]'\n                ),\n                item\n            );\n            drawArea.call(\n                this,\n                item.coords,\n                this.mapEl.find('area[data-index=\"' + item.index + '\"]'),\n                item.type\n            );\n        });\n\n        this.containerWidth = containerWidth;\n        this.containerHeight = containerHeight;\n    }\n\n    /**\n    * @typedef {Element} ShapeElement\n    */\n\n    /**\n     * @this ImageMaps\n     * @param {ShapeElement} shapeEl\n     * @param {Float} x\n     * @param {Float} y\n     * @returns {undefined}\n     */\n    function declareShape (shapeEl, x, y) {\n        this.dragInfo.face.x = x;\n        this.dragInfo.face.y = y;\n\n        shapeEl.attr('data-movable', true);\n    }\n\n    /**\n    * @typedef {PlainObject} MovedCoords\n    * @property {Coords} movedCoords,\n    * @property {VertexCoords} vertexCoords,\n    * @property {ShapeElement} grabEl\n    */\n\n    /**\n     * @this ImageMaps\n     * @param {Float} x\n     * @param {Float} y\n     * @returns {MovedCoords|undefined}\n     */\n    function getMovedShapeCoords (x, y) {\n        const {shapeEl} = this;\n        if (shapeEl.attr('data-movable') === 'false') {\n            return undefined;\n        }\n\n        let movedCoords = [];\n        let vertexCoords = [];\n        const {shapeType} = this;\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            const width = parseInt(shapeEl.attr('width'));\n            const height = parseInt(shapeEl.attr('height'));\n            const movedBottomRightX = x + width;\n            const movedBottomRightY = y + height;\n\n            movedCoords = [x, y, movedBottomRightX, movedBottomRightY];\n            vertexCoords = calculateVertexCoords(SHAPE.RECT, movedCoords);\n        } else if (shapeType === SHAPE.CIRCLE) {\n            movedCoords = [x, y, parseInt(shapeEl.attr('r'))];\n            vertexCoords = calculateVertexCoords(SHAPE.CIRCLE, movedCoords);\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            movedCoords = [\n                x,\n                y,\n                parseInt(shapeEl.attr('rx')),\n                parseInt(shapeEl.attr('ry'))\n            ];\n            vertexCoords = calculateVertexCoords(SHAPE.ELLIPSE, movedCoords);\n        } else if (shapeType === SHAPE.TEXT) {\n            movedCoords = [x, y];\n        } else if (shapeType === SHAPE.POLY) {\n            // Todo\n        }\n\n        return {\n            movedCoords,\n            vertexCoords,\n            grabEl: shapeEl\n        };\n    }\n\n    /**\n    * @typedef {GenericArray} Coords\n    * @property {Float} 0\n    * @property {Float} 1\n    * @property {Float} 2\n    * @property {Float} 3\n    */\n\n    /**\n     * @this ImageMaps\n     * @returns {Coords}\n     */\n    function determineShape () {\n        const {shapeEl, shapeType} = this;\n        let updatedCoords = [];\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            const x = parseInt(shapeEl.attr('x'));\n            const y = parseInt(shapeEl.attr('y'));\n            updatedCoords = [\n                x,\n                y,\n                x + parseInt(shapeEl.attr('width')),\n                y + parseInt(shapeEl.attr('height'))\n            ];\n        } else if (shapeType === SHAPE.CIRCLE) {\n            updatedCoords = [\n                parseInt(shapeEl.attr('cx')),\n                parseInt(shapeEl.attr('cy')),\n                parseInt(shapeEl.attr('r'))\n            ];\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            updatedCoords = [\n                parseInt(shapeEl.attr('cx')),\n                parseInt(shapeEl.attr('cy')),\n                parseInt(shapeEl.attr('rx')),\n                parseInt(shapeEl.attr('ry'))\n            ];\n        } else if (shapeType === SHAPE.TEXT) {\n            updatedCoords = [\n                parseInt(shapeEl.attr('x')),\n                parseInt(shapeEl.attr('y'))\n            ];\n        } else if (shapeType === SHAPE.POLY) {\n            // Todo\n        }\n\n        return updatedCoords;\n    }\n\n    /**\n     * @this ImageMaps\n     * @param {jQuery} vertexEl\n     * @param {Integer} index\n     * @returns {undefined}\n     */\n    function declareVertex (vertexEl, index) {\n        this.setVertexElement(vertexEl);\n\n        let vertexIndex = 0;\n        this.vertexEls.forEach((item, idx) => {\n            if (vertexEl.get(0) === item.get(0)) {\n                vertexIndex = idx;\n            }\n        });\n\n        const coords = this.vertexCoords[vertexIndex];\n        this.dragInfo.vertex.x = coords.x;\n        this.dragInfo.vertex.y = coords.y;\n\n        vertexEl.attr('data-movable', true);\n    }\n\n    /**\n     * @this ImageMaps\n     * @param {Float} x\n     * @param {Float} y\n     * @returns {undefined|MovedVertexCoords}\n     */\n    function getMovedVertexCoords (x, y) {\n        if (this.vertexEl.attr('data-movable') === 'false') {\n            return undefined;\n        }\n\n        let movedCoords = [];\n        let vertexCoords = [];\n\n        const {shapeType} = this;\n        const direction = this.vertexEl.attr('data-direction');\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            switch (direction) {\n            default:\n                // eslint-disable-next-line no-console\n                console.warn('Unexpected direction', direction);\n                break;\n            // 좌상\n            case 'nw':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [x, y, this.shapeCoords[2], this.shapeCoords[3]],\n                    direction\n                );\n                break;\n            // 좌하\n            case 'sw':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [x, this.shapeCoords[1], this.shapeCoords[2], y],\n                    direction\n                );\n                break;\n            // 우상\n            case 'ne':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [this.shapeCoords[0], y, x, this.shapeCoords[3]],\n                    direction\n                );\n                break;\n            // 우하\n            case 'se':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [this.shapeCoords[0], this.shapeCoords[1], x, y],\n                    direction\n                );\n                break;\n            // 상\n            case 'n':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [\n                        this.shapeCoords[0],\n                        y,\n                        this.shapeCoords[2],\n                        this.shapeCoords[3]\n                    ],\n                    direction\n                );\n                break;\n            // 하\n            case 's':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [\n                        this.shapeCoords[0],\n                        this.shapeCoords[1],\n                        this.shapeCoords[2],\n                        y\n                    ],\n                    direction\n                );\n                break;\n            // 좌\n            case 'w':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [\n                        x,\n                        this.shapeCoords[1],\n                        this.shapeCoords[2],\n                        this.shapeCoords[3]\n                    ],\n                    direction\n                );\n                break;\n            // 우\n            case 'e':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [\n                        this.shapeCoords[0],\n                        this.shapeCoords[1],\n                        x,\n                        this.shapeCoords[3]\n                    ],\n                    direction\n                );\n                break;\n            }\n        } else if (shapeType === SHAPE.CIRCLE) {\n            switch (direction) {\n            default:\n                // eslint-disable-next-line no-console\n                console.warn('Unexpected direction', direction);\n                break;\n            case 'n':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(\n                        this,\n                        this.shapeCoords[1] - y\n                    )\n                ];\n                break;\n            case 's':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(this, y - this.shapeCoords[1])\n                ];\n                break;\n            case 'w':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(this, this.shapeCoords[0] - x)\n                ];\n                break;\n            case 'e':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(this, x - this.shapeCoords[0])\n                ];\n                break;\n            }\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            switch (direction) {\n            default:\n                // eslint-disable-next-line no-console\n                console.warn('Unexpected direction', direction);\n                break;\n            case 'n':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    this.shapeCoords[2],\n                    getValidCoordsForCircle.call(this, this.shapeCoords[1] - y)\n                ];\n                break;\n            case 's':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    this.shapeCoords[2],\n                    getValidCoordsForCircle.call(this, y - this.shapeCoords[1])\n                ];\n                break;\n            case 'w':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(this, this.shapeCoords[0] - x),\n                    this.shapeCoords[3]\n                ];\n                break;\n            case 'e':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(this, x - this.shapeCoords[0]),\n                    this.shapeCoords[3]\n                ];\n                break;\n            }\n        } else if (shapeType === SHAPE.POLY) {\n            // polygon의 경우, 드래그 되는 좌표에 따라 이벤트 대상 vertex의 x, y 좌표가 자유롭게 변경.\n        }\n\n        vertexCoords = calculateVertexCoords(shapeType, movedCoords);\n\n        return {\n            movedCoords,\n            vertexCoords,\n            grabEl: this.vertexEl\n        };\n    }\n\n    /**\n    * @typedef {\"se\"|\"sw\"|\"ne\"|\"nw\"|\"w\"|\"s\"|\"n\"|\"e\"} Direction\n    */\n\n    /**\n     * @this ImageMaps\n     * @param {RectCoords} coords\n     * @param {Direction} direction\n     * @returns {RectCoords}\n     */\n    function getValidCoordsForRect (coords, direction) {\n        let [topLeftX, topLeftY, bottomRightX, bottomRightY] = coords;\n\n        if (bottomRightX - topLeftX <= this.shapeLimitCoords.x) {\n            if (direction === 'se' || direction === 'ne' || direction === 'e') {\n                bottomRightX = topLeftX + this.shapeLimitCoords.x;\n            }\n            if (direction === 'nw' || direction === 'sw' || direction === 'w') {\n                topLeftX = bottomRightX - this.shapeLimitCoords.x;\n            }\n        }\n\n        if (bottomRightY - topLeftY <= this.shapeLimitCoords.y) {\n            if (direction === 'se' || direction === 'sw' || direction === 's') {\n                bottomRightY = topLeftY + this.shapeLimitCoords.y;\n            }\n            if (direction === 'nw' || direction === 'ne' || direction === 'n') {\n                topLeftY = bottomRightY - this.shapeLimitCoords.y;\n            }\n        }\n\n        return [topLeftX, topLeftY, bottomRightX, bottomRightY];\n    }\n\n    /**\n     * @this ImageMaps\n     * @param {Float} coordsDiff\n     * @returns {Float}\n     */\n    function getValidCoordsForCircle (coordsDiff) {\n        let radius;\n\n        if (coordsDiff <= this.shapeLimitCoords.radius) {\n            ({radius} = this.shapeLimitCoords);\n        } else {\n            radius = coordsDiff;\n        }\n\n        return radius;\n    }\n\n    /**\n     * @static\n     * @param {Coords} coords\n     * @param {ShapeType} shapeType\n     * @param {Float} widthRatio\n     * @param {Float} heightRatio\n     * @returns {Coords}\n     */\n    function getCoordsByRatio (coords, shapeType, widthRatio, heightRatio) {\n        let adjustCoords = [];\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE ||\n            shapeType === SHAPE.ELLIPSE\n        ) {\n            adjustCoords = [\n                coords[0] * widthRatio,\n                coords[1] * heightRatio,\n                coords[2] * widthRatio,\n                coords[3] * heightRatio\n            ];\n        } else if (shapeType === SHAPE.CIRCLE) {\n            let radiusRatio;\n\n            if (widthRatio >= heightRatio) {\n                radiusRatio = heightRatio;\n            } else {\n                radiusRatio = widthRatio;\n            }\n\n            if (widthRatio === 1) {\n                radiusRatio = heightRatio;\n            }\n\n            if (heightRatio === 1) {\n                radiusRatio = widthRatio;\n            }\n\n            adjustCoords = [\n                coords[0] * widthRatio,\n                coords[1] * heightRatio,\n                coords[2] * radiusRatio\n            ];\n        } else if (shapeType === SHAPE.TEXT) {\n            adjustCoords = [\n                coords[0] * widthRatio,\n                coords[1] * heightRatio,\n                coords[2] * widthRatio\n            ];\n        } else if (shapeType === SHAPE.POLY) {\n            // Todo\n        }\n\n        return adjustCoords;\n    }\n\n    /**\n    * @typedef {GenericArray} RectCoords\n    * @property {Float} 0\n    * @property {Float} 1\n    * @property {Float} 2\n    * @property {Float} 3\n    */\n\n    /**\n     * @static\n     * @param {ShapeElement} shapeEl\n     * @returns {RectCoords}\n     */\n    function convertTextToRectCoords (shapeEl) {\n        const bottomLeftX = parseFloat(shapeEl.attr('x'));\n        const bottomLeftY = parseFloat(shapeEl.attr('y'));\n        const shapeSize = shapeEl.get(0).getBBox();\n        const {width} = shapeSize;\n        const height = parseFloat(shapeEl.attr('font-size')) *\n            FONT_SIZE_RATIO / 2;\n\n        return [\n            bottomLeftX,\n            bottomLeftY - height,\n            bottomLeftX + width,\n            bottomLeftY\n        ];\n    }\n\n    /**\n     * @static\n     * @param {string} coords\n     * @returns {?(Float[])}\n     */\n    function convertStringToNumber (coords) {\n        if (!coords) {\n            return null;\n        }\n\n        return [...coords].map((ch) => parseFloat(ch));\n    }\n\n    //   UTIL FUNCTIONS\n\n    /**\n     * GUID: img의 usemap 속성, map의 name 속성을 unique id로 생성.\n     * @static\n     * @see <http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript>.\n     * @returns {string}\n     */\n    function guid () {\n        /**\n         * @static\n         * @returns {string}\n         */\n        function s4 () {\n            return Math.floor(\n                (1 + Math.random()) * 0x10000\n            ).toString(16).substring(1);\n        }\n        return s4() + s4() + '-' + s4() + '-' + s4() +\n            '-' + s4() + '-' + s4() + s4() + s4();\n    }\n\n    /**\n    * @typedef {PlainObject} Dimensions\n    * @property {Float} width\n    * @property {Float} height\n    */\n\n    /**\n     * @static\n     * @param {HTMLImageElement|string} imageElOrUrl\n     * @todo If this is to handle an image element, other contexts which use\n     *    the passed in URL should also\n     * @returns {Dimensions}\n     */\n    function getNaturalImageSize (imageElOrUrl) {\n        const imageObj = new Image();\n        if (('naturalWidth' in imageObj) && typeof imageElOrUrl !== 'string') {\n            return {\n                width: imageElOrUrl.naturalWidth,\n                height: imageElOrUrl.naturalHeight\n            };\n        }\n        imageObj.src = imageElOrUrl.src || imageElOrUrl;\n        return {\n            width: imageObj.width,\n            height: imageObj.height\n        };\n    }\n\n    $.fn.extend({\n        /**\n         *\n         * @param {Coords} coords\n         * @param {Url} linkUrl\n         * @returns {jQuery}\n         */\n        createMaps (coords, linkUrl) {\n            this.data('image_maps_inst').createMaps(coords, linkUrl);\n            return this;\n        },\n\n        /**\n         *\n         * @param {Coords} coords\n         * @param {Url} linkUrl\n         * @param {ShapeType} shapeType\n         * @returns {jQuery}\n         */\n        addShape (coords, linkUrl, shapeType) {\n            this.data('image_maps_inst').addShape(coords, linkUrl, shapeType);\n            return this;\n        },\n\n        /**\n         *\n         * @param {Integer} index\n         * @returns {jQuery}\n         */\n        removeShape (index) {\n            this.data('image_maps_inst').removeShape(index);\n            return this;\n        },\n\n        /**\n         *\n         * @returns {jQuery}\n         */\n        removeAllShapes () {\n            this.data('image_maps_inst').removeAllShapes();\n        },\n\n        /**\n         *\n         * @returns {jQuery}\n         */\n        destroy () {\n            const imageMapsObj = this.data('image_maps_inst');\n            if (!imageMapsObj) {\n                return;\n            }\n\n            imageMapsObj.removeImageMaps();\n            this.data('image_maps_inst', null);\n        },\n\n        /**\n         *\n         * @param {ShapeStyles} styleOptions\n         * @returns {jQuery}\n         */\n        setShapeStyle (styleOptions) {\n            this.data('image_maps_inst').setShapeStyle(styleOptions);\n            return this;\n        },\n\n        /**\n         *\n         * @param {Url} linkUrl\n         * @param {Integer} index\n         * @returns {jQuery}\n         */\n        setUrl (linkUrl, index) {\n            this.data('image_maps_inst').setUrl(linkUrl, index);\n            return this;\n        },\n\n        /**\n         *\n         * @param {string} text\n         * @param {ShapeStyles} styleOptions\n         * @returns {jQuery}\n         */\n        setTextShape (text, styleOptions) {\n            this.data('image_maps_inst').setTextShape(text, styleOptions);\n            return this;\n        },\n\n        /**\n         *\n         * @param {Url} imageUrl\n         * @param {ShapeStyles} styleOptions\n         * @returns {jQuery}\n         */\n        setImageShape (imageUrl, styleOptions) {\n            this.data('image_maps_inst').setImageShape(imageUrl, styleOptions);\n            return this;\n        },\n\n        /**\n         *\n         * @returns {undefined}\n         */\n        enableClick () {\n            this.data('image_maps_inst').enableClick();\n        },\n\n        /**\n         *\n         * @returns {undefined}\n         */\n        disableClick () {\n            this.data('image_maps_inst').disableClick();\n        },\n\n        /**\n         *\n         * @returns {AllShapeInfo}\n         */\n        getAllShapes () {\n            return this.data('image_maps_inst').getAllShapesInfo();\n        },\n\n        /**\n         *\n         * @param {Coords} coords\n         * @param {ShapeType} shapeType\n         * @param {Float} widthRatio\n         * @param {Float} heightRatio\n         * @returns {Coords}\n         */\n        getCoordsByRatio (coords, shapeType, widthRatio, heightRatio) {\n            return ImageMaps.getCoordsByRatio(\n                coords, shapeType, widthRatio, heightRatio\n            );\n        },\n\n        /**\n         *\n         * @param {Float[]} percentages\n         * @returns {undefined}\n         */\n        zoom (percentages) {\n            this.data('image_maps_inst').zoom(percentages);\n        }\n    });\n\n    /**\n     * @this jQuery\n     * @param {ImageMapOptions} options\n     * @throws {Error}\n     * @returns {ImageMaps|undefined}\n     */\n    $.fn.imageMaps = function (options) {\n        if (this.length === 1) {\n            if (!this.data('image_maps_inst')) {\n                const imageMapsInst = new ImageMaps(this, options);\n                this.data('image_maps_inst', imageMapsInst);\n                return imageMapsInst;\n            }\n            return this.data('image_maps_inst');\n        }\n        if (this.length > 1) {\n            throw new Error('imageMaps instance has already been created.');\n        }\n        return undefined;\n    };\n    return $;\n}\n\nexport default jqueryImageMaps;\n"],"names":["SHAPE","RECT","CIRCLE","ELLIPSE","TEXT","IMAGE","POLY","POLYLINE","POLYGON","defaults","isEditMode","shape","shapeText","shapeStyle","fill","stroke","onClick","onMouseDown","onMouseMove","onMouseUp","onSelect","defaultShapeOptions","rect","circle","ellipse","text","FONT_SIZE_RATIO","NS_SVG","NS_XLINK","$","ImageMaps","container","options","mapEl","svgEl","extend","shapeType","this","shapeImageUrl","shapeCoords","vertexCoords","grabType","containerWidth","containerHeight","touchStartCoords","x","y","dragInfo","face","vertex","shapeLimitCoords","radius","allShapeInfo","coords","linkUrl","imageWidth","width","isNaN","one","proxy","createMaps","call","styleOptions","index","setShapeStyle","imageUrl","setShapeType","shapeEl","data","areaEl","find","detachEvents","type","parent","remove","removeShapeInfo","each","i","_this","removeShape","removeAllShapes","shapeOptions","shapeSecondaryOptions","shapeInfo","percentages","widthPercentage","heightPercentage","length","height","css","setTimeout","_this4","redraw","attachEvents","handler","onTouchStart","onClickShapeFace","element","vertexEl","elements","vertexEls","eventOptions","forEach","on","_this2","eventType","eventHandler","_this3","off","uid","s4","Math","floor","random","toString","substring","guid","attr","usemapName","replace","insertAfter","imageElOrUrl","imageObj","imageHeight","centerX","centerY","isDefaultTextCoords","_toConsumableArray","map","ch","parseFloat","convertStringToNumber","Array","isArray","defaultShapeX","defaultShapeY","defaultRadius","imageSize","Image","naturalWidth","naturalHeight","src","areaType","href","document","createElementNS","svgNativeEl","get","window","onResize","setAttribute","containerPos","position","xmlns","version","zIndex","overflow","top","left","shapeGroupEl","gEl","drawShape","cursor","append","setShapeElement","calculateVertexCoords","vertexTemp","drawVertex","createVertex","setVertexElements","setShapeCoords","updateShapeInfo","url","style","getBBox","bottomRightX","parseInt","bottomRightY","resultX","resultY","join","appendTo","setAttributeNS","cx","cy","eachCoords","vertexArr","drawArea","bottomLeftX","bottomLeftY","convertTextToRectCoords","e","touchCoords","originalEvent","touches","pageX","pageY","targetAreaEl","currentTarget","tagName","toLowerCase","preventDefault","target","changedTouches","open","targetEl","getShapeInfo","targetX","targetY","setImageShape","setVertexCoords","push","is","setVertexElement","vertexIndex","item","idx","updatedCoords","movedX","movedY","movedCoords","movedBottomRightX","movedBottomRightY","grabEl","direction","console","warn","getValidCoordsForRect","getValidCoordsForCircle","offset","abs","widthRatio","heightRatio","getCoordsByRatio","_this5","topLeftX","topLeftY","coordsDiff","adjustCoords","radiusRatio","fn","addShape","destroy","imageMapsObj","removeImageMaps","setUrl","setTextShape","enableClick","disableClick","getAllShapes","getAllShapesInfo","zoom","imageMaps","imageMapsInst","Error"],"mappings":"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"}